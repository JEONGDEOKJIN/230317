// 🟦 오늘은 콜백함수 배울 것 

// 콜백함수가 뭔데? 
        // 함수도 '값' 임 ⭐⭐
        // 함수의 매개변수로 '함수' 를 전달. 그래서, '매개변수로 전달받은 함수' 를 실행!

        // 내가 함수에 코드를 작성하다가, "필요한 순간"에, 매개변수로 받은 함수를, 실행시킨다. 


// 콜백함수 만들어보기 
    // 콜백함수가 들어가게 되는 곳
    function test(callBack) {
        console.log("1번 작업 끝");
        console.log("2번 작업 끝");

        if (true) {
                // 함수를 받았기 때문에, 실행시키려면, () 괄호! 
            callBack()  // 실행이니까 괄호 ⭐⭐⭐ 
        }
    }


    function test2() {
        console.log('나는 콜백함수야!')
    }


    // test 함수에 test2 함수 넘기기 
    test(test2);
        // 이때 test2() 로 쓰면 안 돼. 이름만 전달 ⭐⭐⭐⭐⭐ 


// 비슷한 것 
    let arr = [1,2,3,4];
    arr.map(function(i) {
        console.log(i)
    })
        // map 을 할 때도, 이름이 없는 '함수를 전달' 한 것 임 ⭐⭐⭐ 
        // 아 이놈도 콜백이고, 매개변수로 뭔가를 만든거구나. 


// 🟦 배열 메소드 map 을 흉내내보자 (콜백, 매개변수 활용)

    // 우리만의 객체(dict) 만들기 
    let arr2 = {
        map : function(callBack) {  // 매개변수로 callback 을 받는다.
            
                    // 함수의 매개변수 개수를 알 수 있음. 
                    // callback 에 있는 매개변수 개수를 알 수 있음. ⭐⭐⭐⭐⭐📛📛📛📛📛 
                    // 매개 변수 안 받는 함수 인데, 매개변수 전달하면, 터짐!

            if (callBack.length == 1) {

                let a = 2;
                console.log("나는 map 함수야! 매개변수를 한개 라고 알고 있어👍" + a + "결과야");

                // callback 받은 함수 실행
                callBack(a);

            } else if (callBack.length ==2) {

                let a = 2; 
                let b = 3; 
                console.log("나는 map 함수야! 내가 받은 콜백함수에는 매개변수 2개를 넣는다고 전달받았어.")
                callBack(a,b);

            } else {

            }

        }
    } 

    arr2.map(function(a,b) {
        console.log("나는 콜백 함수야! 전달받은 매개변수는"  + a + b + "이거야" )   
             // w지금 이건 , 문자열이 됨. 형변환이 됨. 
        console.log("나는 콜백 함수야! 전달받은 매개변수는",  + a + b , "이거야" )    
            // w지금 이건 숫자열이 됨 = 파란색!, 콤마를 찍었음 = 타입까지 유지돔 ⭐⭐⭐⭐⭐⭐⭐⭐ 

    });


    // map 추가로 매개변수 넣기 
        // , 를 넣으면 확인 가능 ⭐⭐⭐⭐⭐⭐⭐ 
    arr.map(function(i,v) {
        console.log(i)
        console.log(v)

    })


    function temp(callBack) {
        if (callBack.length === 0) {
            callBack();

        } else if (callBack.length === 1) {
            let temp = "사과";
            callBack(temp)
            
        } else if (callBack.length === 2) {
            let temp = "사과";
            let temp2 = "포도";
            callBack(temp, temp2)

        } else {
            console.log("너어~! 매개변수 초과야! 나는 2개만 받을 수 있어~ Err 임~")
        }

    }

    function temp2(v, b, c) {
        console.log(,"나는 콜백함수야!", v + "를 받았어",  b + "도 같이 받았어!", c)
    }

    // 실행
    temp(temp2)


    // 시사점 
        // 함수를 매개변수로 받을 수 있구나 
        // 전달 받은걸 '조건을 따져서' '원하는 시점' 에 실행시킬 수 있다! ⭐⭐⭐⭐⭐ 




// 🟦 콜백함수 한번 씩 만들고 넘어가자 ⭐⭐⭐ (여기부터, 셀프 실습)
    // 세부 설명
        // 객체 안에 함수를 만들고 -> 콜백함수를 만들면 된다. 
        // key 값은 원하는 대로 이름 지정 
        // 매개변수는 3개 까지 받을 수 있는 함수
        // 연습겸, 전달받은 콜백함수는, '구구단 기능' 을 보여주는 함수. 
            // 매개변수 1개 받으면 2단 
            // 매개변수 2개 받으면 2단, 3단 보여주고 
            // 매개변수 3개 받으면 2단, 3단, 4단, 다 보여주면 된다.  
    
    // 함수 부연 설명
        // 1. 일반함수 : 걍 일반 함수
        // 2. 객체 안에 있는 함수 : 메소드  ⭐⭐⭐⭐⭐ 



    // ❓❓ 
        // callback 함수를 '실행' 시키려면, 1) '조건문' 을 같이 써야만 해? 2) 아니면, 원하는 시점에 실행시키려고 조건문? 
        // callback 함수 '선언' 은, 이번 경우에는, 객체, 안에다가 

    // ⭐⭐ 
        // 부모 함수의 인자로 넣을 때는 괄호 없이 (왜냐면, 함수도 값이니까)
            function djtest(callBack){  }
        // 부모 함수 안에서, 조건 true 이후 실행시킬 때는, 괄호 있게!
            function djtest(callBack) {
                // callback 함수 실행시키는 조건이 만족되면 -> 실행 
                if (true) {
                    callBack()}}


    // 콜백함수가 들어가게 되는 곳 
        // 콜백함수 들어가는 1) 자리 2) 실행조건 준비 
    function 본래함수 (callBack) {
        console.log("이게 뭘까");
        console.log("이게 뭐지");

        // callback 함수 실행시키는 조건이 만족되면 -> 실행 
        if (true) {
            callBack()
        }
    }

    // 콜백함수 준비
        // 들어가서, 조건이 맞으면, 이제 이게 실행되는거야. 
    function 넣을함수() {
        console.log(`나는 callBack 함수야 \n 
        나는 본래함수에 넣을 거야. \n 
        넣는다는 건, 매개변수로 들어가는 거야. \n 
        매개변수로 들어가면, 실행조건이 true 일 때 실행되게 될거야 \n 
        본래함수에서 callBack 자리에 들어가게 되는 함수야 \n 
        `)
    }

    // 콜백함수가 들어간, 본래함수 실행시키기 
        // 그냥, 콜백함수 자체만 실행해도 되는데, 본래함수 안에 들어가서, 특정 조건 안에서, 콜백함수가 실해되게 한다. 
    본래함수 (넣을함수)
        // [해석]
            // 본래함수를 실행할거야 
            // 그때, 매개변수로 '함수' 를 받게 할거야 (어떤 동작을 하게 할거야)
            // 이 동작이 언제 어떻게 할지? 는 내가 조건을 줘서 정할거야.
            // 그러면, 이 함수는 이제 부터 '특정 조건에서 어떤 함수를 만족시키는 함수' 가 되는거야. 
        // [쉽게 생각하면]
            // '본래 함수' 를 실행시키고 싶어 
            // 그때, '다른 함수' 도 같이 실행시키고 싶어 
            // 근데, '어떤 조건' 을 줘서 true 면 실행시키고 싶어. 그때 쓰는게 콜백❓❓❓❓❓ 

    
    // ✅ 다시 연습

        // map 기능 살짝 맛보기 
        let arr_2 = [1,2,3,4];

        arr_2.map(function(i) {
            console.log(i)
        })

        // map 같은 함수를 만들어보자 

            // 1️⃣ [함수 정의] 객체 안에 하기
            let arr_3 = {

                // '구구단' 이라는 이름으로 부를거야. 
                    // 구구단이 불리면, 이 익명 함수가 실행될거야 
                    // 이 익명함수는 또, 매개변수를 받을 수 있어. 
                    // 여기 callBack 에서 막혀 😥😥😥😥😥 
                gugu2 : function(callBack) {

                    if (callBack.length == 1) { 
                        let a = 2;
                        console.log(`callback 함수의 매개변수 a 에 ${a} 가 들어왔어. 그 다음에 callback 이 실행됨`);
                        callBack(a);
                    } else if (callBack.length == 2) {

                        let a = 2;
                        let b = 3;
                        callBack(a,b);
                            // [g]


                    }
                }

            } 
                // [해석]
                    // 진짜 신기한게, callBack 함수에 length 를 붙이면, 매개변수 개수가 보인다❓❓❓


            // 2️⃣ [함수 실행]

                // 1. 콜백함수를 무명함수로 여기에 정의해서 실행하기 (객체로 실행된 놈이면 이렇게 해야하나? / 이렇게 되면 출력이 2개 되나?)

                    arr_3.gugu2(function(a,b) {
                        console.log("arr_3.gugu2 를 실행해봤음. / 그러면?")
                    })


                // 1.1 그러면 이것도 되나? 

                    arr_3.gugu2(temp2)


                // 2. 콜백함수를 다른 곳에 정의해서, 실행하기 

                        function temp(callBack) {
                            if (callBack.length === 0) {
                                callBack();

                            } else if (callBack.length === 1) {
                                let temp = "사과";
                                callBack(temp)

                            } else if (callBack.length === 2) {
                                let temp = "사과";
                                let temp2 = "포도";
                                callBack(temp, temp2)

                            } else {
                                console.log("너어~! 매개변수 초과야! 나는 2개만 받을 수 있어~ Err 임~")
                            }

                        }

                        function temp2(v, b, c) {
                            console.log("나는 콜백함수야!", v + "를 받았어", b + "도 같이 받았어!", c)
                        }

                        // 실행
                        temp(temp2)







                // 📛📛📛📛📛📛  
                    // 1. gugu2 안에 암것도 안 들어가도 되지? 
                        // 값이 안 들어가면, undefined 가 되고 -> 그에 맞게 처리를 해줘야 한다. 
                        function greet(name) {
                            if (name === undefined) {
                                console.log("Hello, anonymous!");
                            } else {
                                console.log(`Hello, ${name}!`);
                            }
                        }
                        greet(); // "Hello, anonymous!"
                    // 2. 매개변수로 '함수' 가 들어갈 수 있음. 그 매개변수 이름을 그냥 callback 이라고 하는 건가? 
                    // 3. '함수' 도 자료형이고, 함수에 length 를 쓰면, 그 함수가 가진 매개변수가 나오는건가? 
                
                
                // ⭐⭐⭐ 알게 된 것 
                    // 1. '함수' 자료형에 'length 메소드'를 사용하면, -> '해당 함수'가 갖고 있는 '매개변수 개수'가 나온다. ⭐⭐⭐
                        // length 가 메소드 였네!!!!! 
                    

                // ✅ 기타 필기 

                    // 보통, 객체 안에서 함수가 정의되면, .gugu2 까지만 썼던거 같은데? ex) push() 의 경우
                    //     // 함수 선언      
                    //     const obj_ex = {

                    //         a : "나는 객체 안에 있는 value 야", 
                
                    //         push : function(num) {
                    //             console.log("나는 obj 라는 객체 안에, push 라는 key 에 대응하는 value 에 있는 익명함수야!");
                    //             console.log(`${num} 을 매개변수로 받았어!`);
                    //         }
                    //     }
                    //     // 함수 실행
                    //     console.log(obj.a)
                    //     console.log(obj.push(2))
                    
                    // // 자, 객체안에 정의된게 일반함수면 그렇고, 
                    //     // 객체 안에 정의된게 callback 함수면, 실행할 때, 'function 과 매개변수' 를 넣어줘야 하는 건가? 








// 🟦 교수님이 풀이해주심 

    // 객체를 선언하고 
    let obj2 = {

        gugu : function(callBack) {
            
            switch (callBack.length) {
                case 1:
                    // 2단 보여주기 
                    callBack(2)
                    break;
            
                case 2:
                    // 2단, 3단 보여주기
                    callBack(2);
                    callBack(3);

                    break;
            
                case 3:
                    callBack(2);    
                    callBack(3);    
                    callBack(4);
                    
                    break;
            
                default:
                    console.log("매개변수 개수 확인해봐")
                    break;
            }

        }
    }

    // 구구단  함수 만들기 
        // 지금 매개변수 b,c 는 사용하지 않고 있음. 
        // 매개변수가 a,b,c,d, 까지 늘어가면 -> 매개변수 개수 확인해~ 가 뜬다. 
    function temp3(a,b,c) {
        for(i = 1; i < 10; i++) {
            console.log(`${a} x ${i} = ${a * i}`)
        }
    }

    // 기능확인 
    temp3(2) // 2단 
    temp3(3)

    // 시사점 
        // 어떻게 만드는지는 상관없지만, '기능단위' 로 함수 만드는 습관은 키우는게 좋음 ⭐⭐⭐ 
        // '기능에 대한 정리' 하는게 필요

    obj2.gugu(temp3)

    // 시사점 
        // 콜백 중요 ⭐⭐⭐⭐⭐ 
        // 잘 정리해야 함 



// 🟦 스택

    // 함수가 실행되면, '스택' 이라는 곳에 '쌓인다.' 

    // '스택' 은? 
        // '후입, 선출' 

    // 큐는? 
        // 선입, 선출 

    // 콜 스택 이란? 
        // 스택은 '데이터를 사용하기 위해', '잠시 저장' 하는 곳 
        // 데이터를 '쌓아놓는다.' 
        // 쌓아두고, 후입선출로, 마지막에 추가된 데이터부터 제거
        // ex) 상자에 짐을 넣고 -> 보이는 건 맨 위에 있는 짐. 맨 위에 있는 것 부터 꺼낸다. 

        // 함수 실행 컨텍스트 '함수를 실행' 하게 되면, -> '스택에 추가' 된다.
        // 함수 실행 컨텍스트, 함수가 반환(return?)될 때, 스택에서 제거된다. 
        // 함수 실행 컨텍스트 : 함수가 실행될 때 마다 생성된다. 함수의 실행 정보를 가지고 있다.
        // 콜 스택은 함수가 실행되면 -> 실행 컨텍스트 저장하는 스택의 구조 
        // 콜 스택은 컴퓨터의 메모리 크기, 운영체제(OS) 에 따라 크기가 다름. 
        // 콜 스택이 초과되면, -> 이때 뜨는게 'stack overflow' 에러가 발생 (더 이상 쌓지 못 하는 상태라서 실행 못해~ 비워줘~)

        // stackoverflow 가 발생하는 예 
            // 함수를 무한으로 실행할 시. 


    // 콜스택 이해위해 함수를 만들어보자 
    function fun1() {

        fun2();

    } 

    function fun2() {

        fun3();

    }

    function fun3() {
        console.log("난 3번 함수. 끝으로 실행한 함수야")
    }

    fun1();
        // 자바스크립트 코드 전체를 실행하고 (1️⃣전역 실행 컨텍스트가 실행)
        // 그 다음 fun1 함수가 실행됨. 
        // 함수가 실행되면 -> '2️⃣ fun1 함수 실행 컨텍스트' 가 만들어짐. 
            // -> 그 다음 3️⃣ fun2 함수 실행 컨텍스트가 생성 
            // -> 그 다음, 4️⃣ fun3 함수 실행 컨텍스트가 생성
        // 이렇게 스택에 쌓이게 됨. 
        // 마지막에 추가된 fun3 부터 '실행 컨텍스트 제거' 
            // 그 다음 fun2 함수 실행 컨텍스트 제거 
            // 그 다음 fun1 함수 실행 컨텍스트 제거 
        

        // 위의 사항을 브라우저에서 확인하기 
            // 1. 개발자 모드 열고 > f12 > 디버깅 모드 활성화 (컨트롤 + f8)
            // 2. break point 찍기 : 함수, 코드줄 옆에, 클릭 
                // 실행하다가, 해당 break point 에 도달하면, 잠시 실행을 멈춘다. 
                // 재생 버튼 누르면, 다음 포인트가 있는 곳 까지 실행하다가 멈춘다. 
                // 이걸로 디버깅 용이 
                // 값이 어떻게 변하는지 확인이 가능 ⭐⭐⭐⭐⭐⭐ 



// 우리는 일반함수를 알고 있어. 못 쓰면, 계속 만들어보자. 
// 일상에서 코드가 보이기 시작하면, 개발자가 된거야. 하하하하하 하...아... 


// 🟦 '화살표 함수' 

    // 의의 
        // 일반함수 
            // function 함수명() {}
            // 변수명은 반드시 영어로 ⭐⭐⭐ 
    
        // ES6 에서 새로 나온 함수 방식
            // ES6 문법 : 템플릿 리터럴 
    
    // 궁금한거 
        // 굳이 잘 되는데 왜 화살표가 필요 ?

    
    // 사용법 
        // => 
        // 화살표 모양으로 선언.

        // 선언 방식 ⭐⭐⭐⭐⭐ 
            // '괄호' 에 매개변수 
        let temp4 = () => {
            console.log("나는 화살표 함수야!")
        }

        // 실행 
        temp4()


    // 일반함수와 화살표 함수의 차이점
        // 1. 함수에서 값을 반환할 때, return 사용 여부 
            // 화살표 함수에서는 return 없이 반환 가능 
            
            // 1) return 이 있어야 반환되는 경우
            let temp5 = () => {
                return 5;
            }

            let ab = temp5() ;  // 함수를 실행시키면, ab 에 들어간다!!! // 리턴이 없으면 안 들어간다⭐⭐⭐⭐⭐ 
            console.log(ab)

            // 2) 화살표함수 써서 return 이 없어도, 반환되는 경우 ⭐⭐⭐⭐⭐⭐⭐ 
            let temp6 = () => 5;
            let abc = temp6() ;  // 함수를 실행시키면, ab 에 들어간다!!! // 리턴이 없으면 안 들어간다⭐⭐⭐⭐⭐ 
            console.log(ab)


        // 2. [제일 중요하고 큰 차이점/단골면접질문] this 라는 개념 
            // this 키워드 : '자바스크립트 객체' 를 '참조' 하는 특별한 구문/ 
                // this를 찍으면 -> window 객체 같은 객체 를 가져올 수 있어 

            // 전역 공간에서 this 를 쓰면 뭐가 나오나? 
            console.log(this) // 그러면, window 객체가 나옴 

            // window 객체는? 
                // BOM 
                // 브라우저 오브젝트 모델 
                // '브라우저' 를 '객체 모델' 로 표현한 것. 

            // BOM 은 어떤 역할을 해? 
                // 브라우저의 기능들에 접근할 수 있음. 
                // WINDOW 객체임
            
            // 일반함수와 화살표 함수의 차이 ⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐
                // this 를 썼을 때 가리키는 대상이 다름 
                // ⭐일반함수⭐의 경우, this 가 가리키는 것은, '함수가 실행 될 때, 그 위치(그 scope)(다이나믹 scope)' 에서 this 를 가져온다.
                    // ⭐'실행된 곳'⭐ 에서 가져온다. 
                // ⭐화살표 함수⭐의 경우의 this : 화살표 함수 내부의 this 는 화살표 함수를 '선언' 한 위치에서 this 를 가져온다. 
                    // ⭐'선언된 곳'⭐ 에서 가져온다. -> 렉시컬 스코프 
                    // 선언한 위치가, 객체 안에 있으면, this는 객체를 가리킨다.  

                    let obj = {

                        a : function () {
                            b()
                            console.log(this) 
                            // 객체 안에서 '실행' 되니까, this 는 어떤 객체를 가리키냐면, a 객체를 가리킨다. 

                            let c = () => {
                                console.log(this);  // 화살표 함수는 선언된 곳의 객체를 가져온다. 
                            }
                            c()

                            // d() // 선언된 곳이 전역 변수니까 -> 실행을 a 안에서 해도, window 가 나와. 
                        }
                    }


                    function b() {
                        console.log(this)
                    }

                    obj.a();
                        // /실행된 공간이 전역 공간 이니까 -> this 는 window 로 나와
                    

                    // 화살표 함수는 전역변수에서 선언되었으니까 -> window 를 가져온다.
                    let d = () => {
                        console.log(this);
                    }




// 🟦 비동기 함수, 동기 함수 

    // 동기 라는 건? 
        // 실행하다가 - 실행 끝나면 실행
        // '순차적' 으로 실행된다. 
        // 작업이 끝나고 -> 다음 작업이 진행 -> 끝나고 다음작업 진행

    // 비동기는? 
        // 다른 작업이 동작되는 와중에도, 자기는 실행된다. 
        // 다른 코드들과 함께 동기적으로 실행되지 않는다. 
        // 전체 코드는 동기적으로 실행되다가, ⭐비동기 함수를 만나면, 비동기 함수를 비동기로 실행하고,⭐ 다시 동기로 실행한다. 
        // 순차적으로 실행되지 않고, 작업을 하는 도중에도 다른 작업이 가능
        // '비동기 함수' 라는 것! 즉 '함수' 라는 것 ⭐⭐⭐ 

        // node.js 에서 잡힐 것 
        // ex) 서버에서 값을 가져오는 동안, 웹 페이지가 뜬다. ⭐⭐⭐⭐⭐ 
            // 데이터 가져오는 걸 = 비동기로 하고, 페이지는 동기적으로 하고 ⭐⭐⭐⭐⭐⭐⭐ 
            // 1) 서버에서 값을 가져오는 동안 = 비동기로 작업 2) 다른 작업들, 페이지가 돌아가는 건, 동기적으로 작업된다. 


    // 비동기 함수의 예시? 
        // settimeout 은 비동기 함수, 
            // 매개변수를 2개 받고, 첫번째가 함수, 두 번째는 시간값을 숫자타입으로 넘겨준다.
            // 1000 = 1초
        setTimeout(function() {
            console.assert("나는 1초 뒤에 실행되고, 나는 비동기 함수에서 실행되었어")
        }, 1000);

        setTimeout()
        console.log("나는 동기임");
        console.log("나는 동기임");

    // 만약, setTimeout 이 '동기함수' 였다면? 
        // 1000초간 기다렸다가 -> "나는 동기임!" alert 가 떴을 것 ⭐⭐⭐⭐⭐ 
        // 그런데, steTimeout 은 '비동기 함수' 이기 때문에, setTimeout 을 바로 실행하지 않고 -> console.log 로 이동 

    // 모르는 부분 📛📛📛 
        // 근데, 시간을 걸었을 뿐, 동기적으로 되는거 아닌가? 
        // 비동기 함수는 일반적으로 이렇게 생긴건가? 

    // ⭐⭐⭐ 동기함수, 비동기 함수는 꼭 정해져 있어, 



    // 🟦 let, var, const 는 꼭 써야 함. 
    // window 객체

    let a = "";
    
    function temp6() {
        let b = "";
            // 이건 함수 안에서 만 쓸 수 있음. 
            // 함수 밖에서 찍더라도 안 나와
        
        c = "aa"    // 이렇게 하면 '전역 변수' 가 된다 ⭐⭐⭐⭐⭐ 
    }

    temp6();
    // 이렇게 되면?    
        // var 아님 
        // 변수로 선언된게 아님 
        // window 객체에 key 값으로 추가된다. ⭐⭐⭐⭐⭐⭐⭐ 
            console.log(window.c)
            console.log(c)
        // 이러면 캊을 수가 없다. 

    console.log(c);
    console.log(b);