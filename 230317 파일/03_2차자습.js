// 🟦 콜백함수 
    // 의의 
        // 함수도 '값' 임 ⭐⭐
        // 함수의 매개변수로 '함수' 를 전달. 그래서, '매개변수로 전달받은 함수' 를 실행!
        // 내가 함수에 코드를 작성하다가, "필요한 순간"에, 매개변수로 받은 함수를, 실행시킨다.





// 🟦 콜백함수 만들기
    // (매개변수로 함수를 쓰고자 하는 경우)(콜백함수를 쓰고자 하는 경우)

    // 1. 콜백함수를 품고 있는게 일반함수인 경우
    
        // 1.1 고차함수 선언
        function test(callBack) {

            if (true) {
                callBack()
            }
        }

        // 1.2 callBack 변수에 넣을 함수 (콜백 함수) 선언 
        function test2() {
            console.log("이게 본함수의 매개변수로 들어가는 함수가 될거야. 함수값이지.")
        }

        // 1.3 callBack 함수를 실행시키는 고차함수를 '실행' 하기 
        test(test2)



    // 2. 객체 활용해서 콜백함수 사용하기 
        // 객체 활용해서, 함수 안에 함수를 사용하기 
        // 객체 안에 함수 안에 함수를 만들어서 사용하면 -> 주로, 익명함수를 사용하게 됨. 
        // 익명함수를 사용하면, '한번 사용하고 버림' -> 메모리에 저장하지 않아도 됨. 
        
        // 2.1 객체선할 때, 익명함수(콜백함수) 만들기 (만들기❓) 
        let arr3 = {

            map : function(callBack) {

                // 요기에, 함수가 들어오면, 뭘 하게 할거야? ⭐⭐⭐⭐⭐ 
                    // 함수의 매개변수 개수를 체크하게 할거야
                    // 이것 말고, 더 복잡한, 기능을 실행하게 할 수 있어. ⭐⭐⭐⭐⭐  
                console.log(callBack.length)
                console.log(`여기는 선언 같은건 없어. 선언하는 순간, 메모리에 저장되거든 \n
                지금은 무명함수 인데, 메모리 저장없이, 이건 한번 실행되고 사라져 \n
                메모리에 저장된다는 건, 선언하고 저장하고, 부르면 달려오는 것 처럼!`)

            }
        }


        // 2.2 저장된 객체를 불러서, 사용하기.
            // 아직 사용하는 부분은 잘 모르겠네 📛📛📛 
            // 암튼 이렇게 부르면, 뭔가 사용할 수 있어. 
        
        arr3.map(function(a,b){
            console.log("이렇게 2개의 매개변수가 들어왔네 ");
        })  // 이 함수가 들어오면, 매개변수를 리턴해주는 걸 하고 싶은데, 아직... 음... 😥😥😥


            // [해석] 
                // arr3.map 을 쓰려고 해 
                // 응? 매개변수로 ⭐함수값⭐을 받네? 
                // 응? 함수값이 들어가면 -> 이런저런 기능을 하네? -> 오캐이. 
                // 그러면, 어떤 함수를 넣을까? 
                    // 1) 여러번 쓰고 싶으면, 메모리 써서, '일반 함수'를 정의해서 넣을 수 있을거 같고 
                    // 2) 한 번 쓰고, 메모리 아끼고 싶으면, '익명 함수' 쓰면 될거 같은데



        // 2.3 콜백함수가 조금 더 복잡한 기능을 하는 예제들 

            // 2.3.1 : 일반함수 활용
                function temp(callBack) {

                    if (callBack.length === 0) {
                        callBack();

                    } else if (callBack.length === 1) {
                        let temp = "사과";
                        callBack(temp)  // 새로 들어올 함수에, 사과를 넣는거야. 
                    } else if (callBack.length === 2) {
                        let temp = "사과";
                        let temp2 = "포도";
                        callBack(temp, temp2) // 그 들어오는 함수에, temp 랑, temp2 를 넣어서 실행해줘 ⭐⭐⭐ 
                        
                        console.log("이건, 고차함수에서 실행하는 것👍")
                        // 콜백함수의 인자가 2개면, 1)기본적으로 이 공간에 있는 것도 실행이 되고 2) 순서에 따라, callback 함수 까지 실행 
                        

                    } else { 
                        console.log ("너! 매개변수 초과야! 2개 까지만 받을 수 있어!")
                    }
                }

                // 콜백에 넣을 함수 정의 
                function temp3(v, b) {
                    console.log(`나는 콜백함수야! ${v} 이 변수를 콜백함수에 받았어 \n
                    ${b} 이것도 받았네 \n 
                    참고로, 이건, 콜백함수에서 실행하는 것 👍
                    `)
                }

                // 함수 실행 
                temp(temp3)
                    // [해석]
                        // temp 를 실행할 때, callback 자리에 temp3 함수를 넣어서 읽으면 된다. ⭐⭐⭐⭐⭐ 
                        // ⭐⭐⭐ 1) 고차함수에 있는 것도 실행이 되고, 2) 고차함수 순서에 따라서 콜백 함수가 실행되며 3) 콜백함수에서 정의한 기능에 따라서 또 실행된다. 
                
            
            
            // 2.3.3 : 객체 활용해보기 

                // 콜백함수가 포함된 객체 선언
                let arr2 = {

                    map : function(callBack) { // map key 에 담긴 함수 안에는 또 함수를 담을거야. 이걸 실행하면, 함수가 2개 실행되는거지. 그걸 callback 으로 받을거야. 

                        // 그럼, 함수가 들어오면 뭘 할거야?
                            // 함수가 들어오면, 우선, 매개변수 개수를 파악할거야. 
                                // 매개변수가 1개면 -> 이렇게 해줘 
                                // 매개변수가 2개면 -> 이렇게 해줘 등등
                        if (callBack.length == 1) {
                        // "콜백함수가 들어오고, 그게 매개변수가 한개인 함수라면, 여기가 실행될거야.
                            // 변수 a 를 만들어서 2를 넣고 
                            // 새롭게 들어온 함수에 해당 변수를 넣어줘 
                            
                            let a = 2; 
                            callBack(a);

                        } else if (callBack.length == 2) { 
                            // 콜백함수가 들어오고, 매개변수가 2개라면, 이 블록이 실행 
                                // 새로운 변수 2개를 만들고, 값을 할당해서 -> 변수에 넣기.  
                            
                                let i = 2;
                                let v = 88;
                                callBack(i,v) 
                                // [해석] 
                                    // 익명함수 안에 들어가는 파라미터는 또 여기에 있네
                                    // 익명함수는 만들어지기만 했지, 아직 실행된건 아니니까 그치? 
                                    // '익명함수의 실행' 은 여기네 ⭐⭐⭐⭐⭐ 
                                    // 근데, '익명 함수' 에 선언은 없다고 했는데, 익명함수가 만들어지고, 실행되는건 뭐라고 부르지? 📛📛📛📛📛 
                                    // '익명함수가 매개변수를 수혈받고 있음.' ⭐⭐⭐ 
                                    // 매개변수로 전달하는 변수와, 콜백함수에서 전달하는 변수명이 같아야 함. 
                        } else {

                        }

                    }

                }

                // 객체 활용해서 콜백함스 사용해보기 
                    // 예제 1
                        arr2.map (function(a,b) { 
                            // let a = 3; 
                            // let b = 2;
                            console.log("콜백함수~~~ 전달받은 매개면수는",  + a + b, "이야아")
                                // 콤마를 찍어서, 애초의 a 데이터 타입인 숫자가 유지된다. -> 콘솔에서 파란색으로 보인다.                     
                            console.log("콜백함수~~~ 전달받은 매개면수는" + a + b + "이야아")
                                // 앞 뒤가 문자열 이기 때문에, + 를 적으면, a 와 b 가 문자열로 들어간다. -> 콘솔에서 문자열과 같은 숫자

                        })
                            // [해석]
                                // arr2 객체에 있는 key 값이 map 인 곳에 있는 함수를 쓸거야 
                                // 이 함수는 인자로 함수를 받네? 
                                // 그러면 어떤 함수를 넣을까? 
                                    // 1) 일반함수 2) 익명함수 두 가지 를 넣을 수 있어. 
                                    // 여기에는 익명 함수를 써보자.
                                // 신기하네, 1) 익명함수를 여기에 썼고, 2) 익명함수에 들어가는 파라미터는 또, 본체함수 안에 있고 ⭐⭐⭐⭐⭐   
                
                    // 예제 2
                        arr2.map(function(i,v) {
                            console.log(`콜백 함수에서 전달받은 첫 번째 인자는? ${i}`)
                            console.log(`콜백 함수에서 전달받은 두 번째 인자는? ${v}`)
                        })


            // 2.3.4 : 구구단 ⭐⭐⭐⭐⭐ 
                // 1) 매개변수 1개를 받으면 2단, 2) 매개변수 2개를 받으면 2단, 3단 3) 매개변수 3개를 받으면 2,3,4단 보여주기 
                
                // 함수를 담은 객체 정의 
                let obj2 = {

                    gugu : function(callBack) {
                        
                        switch (callBack.length) {
                            case 1:

                                // 2단 보여줘
                                callBack(2)                            
                                break;
                                
                            case 2:

                                // 2단 보여줘
                                callBack(2)                            
                                callBack(3)                            
                                break;
                                
                            case 3:

                                // 2단 보여줘
                                callBack(2)                            
                                callBack(3)                            
                                callBack(4)                            
                                break;

                            default:
                                console.log("매개변수는 최대 4개 까지만! 매개변수 개수 확인해!")
                                break;
                        }
                    }
                }

                // 구구단 함수 만들기 
                function gugudan(a) {
                    for (i = 1; i < 10; i++) {
                        console.log(` ${a} x ${i} = ${a * i}`)
                    }
                }

                // 기능확인 
                gugudan(2)
                gugudan(7)


                // gugu 객체에 담긴 메소드의 콜백함수로 gugudan 넣어서 실행해보기 
                obj2.gugu(gugudan)
                    // callBack 은 '값' 을 넣는 자리이기 때문에, 함수 이름만! ⭐⭐⭐⭐⭐ 
                    // 실행을 해야한다면, gugudan() 까지 해야.



// 🟦 스택 

    // 스택이란? 
        // 함수가 실행되면, '스택' 이라는 곳에 '쌓인다.' 
        // 데이터를 사용하기 위해, '잠시 저장' 되는 곳 
            // EX) 박스에 짐을 넣는 것 처럼 
            // EX) 개발자 도구 - source - call stack 에 있는 것들. 
        
        // 쌓아둔 것을 꺼내려면? 
            // 정석은, '위에서 부터, 하나씩 꺼낼 수 밖에' 없음. 
            // 그러면, '늦게 들어온 놈이, 먼저, 나가게 된다.' 
            // 이것을 '후입 선출' 이라고 한다. 

        // Cf. 큐 는? 
            // 큐 는, 먼저 들어온 걸, 가장 먼저 빼는 것. 

        // Cf. 옵시디언 `202303161040_3주차_목요일_수업 필기` 에 사진 캡쳐 있음. 

    // 콜 스택 이해하기 (함수 실행 컨텍스트 살펴보기)
        // - 함수 실행 컨텍스트 : '함수를 실행' 하게 되면, -> '스택에 추가' 된다.
        // - 함수 실행 컨텍스트 : 함수가 '반환'되면, -> 스택에서 '제거' 된다. 
        // - 함수 실행 컨텍스트 : 함수가 실행될 때 마다 생성된다. 함수의 실행 정보를 가지고 있다.
        // - 콜 스택은 함수가 실행되면 -> 실행 컨텍스트 저장하는 스택의 구조 
        // - 콜 스택은 컴퓨터의 메모리 크기, 운영체제(OS) 에 따라 크기가 다름.
        // - 콜 스택이 초과되면, -> 이때 뜨는게 'stack overflow' 에러가 발생 (더 이상 쌓지 못 하는 상태라서 실행 못해~ 비워줘~)
            // stackoverflow 가 발생하는 예 
            // 함수를 무한으로 실행할 시. 
    

    // 예시 
    function fun1() {
        fun2();
    }

    function fun2() {
        fun3();
    }

    function fun3() {
        console.log("난 3번 함수! 끝으로 실행한 함수!")
    }

    fun1();

    // [해석]
            // 자바스크립트 코드 전체를 실행하고 (1️⃣전역 실행 컨텍스트가 실행)
        // 그 다음 fun1 함수가 실행됨. 
        // 함수가 실행되면 -> '2️⃣ fun1 함수 실행 컨텍스트' 가 만들어짐. 
            // -> 그 다음 3️⃣ fun2 함수 실행 컨텍스트가 생성 
            // -> 그 다음, 4️⃣ fun3 함수 실행 컨텍스트가 생성
        // 이렇게 스택에 쌓이게 됨. 
        // 마지막에 추가된 fun3 부터 '실행 컨텍스트 제거' 
            // 그 다음 fun2 함수 실행 컨텍스트 제거 
            // 그 다음 fun1 함수 실행 컨텍스트 제거 




    // 시사점 
        // 이론적으로는 알겠어. 스택을 코드로 구현하는 경우는 언제 일까? 
        // ⭐⭐⭐⭐⭐ 함수 3개가 '병렬'이 아니라, '중첩' 되어 있으면, -> '무엇이 먼저 쌓이는지', '무엇이 먼저 실행되어서 제거 되는지.' 가 문제가 되는 것 같음 ⭐⭐⭐⭐⭐ 
        // 아, 이걸 알아야, 뭐가 먼저 실행되는지를 알고, 짤 수 있을거 같은데?


// 🟦 개발자 모드 확인해서 디버깅 하기 

    // (옵시디언에 필기함)
        // 1. 디버깅 모드로 들어가기 
        // - 개발자 모드 열고 > f12 > 디버깅 모드 활성화 (컨트롤 + f8) 

        // 2. 원하는 코드 line 에 break point 찍기 

        // 3. 브라우저 새로고침

        // 4. 재생버튼(resume script execution / f8) 눌러서 확인 
        // - 함수가 실행되다가, break point 찍은곳에서 어떤 일이 벌어지는지 알 수 있음 
        // - ex) 재생버튼 한번 누르면 -> 첫 번째 함수가 실행되고 -> `call stack` 에 쌓인다.
        // - ex) 실행될 때는 fun1 > fun2 > fun3 순서로 실행된다. 

        // 5. 화살표 아래 버튼(step into next function call) 을 눌러서, 실행된 함수가 컨텍스트에서 제거되는 걸 확인 
        // - 제거될 때는 fun3 > fun2 > fun1 순서로 제거된다. 



// 🟦 화살표 함수 

    // 의의 
        // ES6 에서 새로 나온 함수 형식 
        // EX) 템플릿 리터럴 (백틱 사용 ``) 도 ES6 신문법

    // syntax (문법)
        // 1) 선언
        let temp7 = () => {
            console.log("나는 화살표 함수야!")
        }
        // 2) 실행 
        temp7()
    
    // '일반함수'와 '화살표 함수' 의 차이점 ⭐⭐⭐⭐⭐ 
        // 1. 함수에서 값을 반환할 때, return 사용하는지 여부
            // 1) 일반함수 : return 이 필요 
            // 2) 화살표 함수 : reeturn 없이도, 반환 가능 

            // 1.1 화살표 함수에서 return 있을 때, 반환하는 경우 
                // 2.1 선언 
                let temp5 = () => {
                        return 5;
                    }
                // 2.2 실행 
                let ab = temp5()
                    // [해석] ⭐괄호를 써서⭐, 함수를 실행시키면, return 을 내뱉고, 그 값이 ab 에 들어간다!  
                console.log(ab)

            // 1.2. 화살표 함수에서 return 없이, 반환하는 경우 ⭐⭐⭐⭐⭐ 
                // 3.1 선언 
                        // ⭐⭐⭐ 선언에서 { } 를 사용하지 않음 ⭐⭐⭐ 
                let temp6 = () => 55555;

                // 3.2 실행 
                let abc = temp6()
                console.log(abc)



        // 2. 'this 명령어 사용시, 어떤 객체를 참조 하는가!' 가 다름


        // 2.0 this 란? 
            // this는 '함수가 호출'될 때 '해당 함수가 속한 객체'를 가리키는 예약어


        // 2.1 '전역 공간' 에서 this 를 쓰면 뭐가 나오는가~ 
                    
            // console.log(this)
                // [결과물 해석] ⭐⭐⭐ 
                    // winddow 객체가 콘솔창에 찍힘. 
                    // this = window 객체를 의미. 

        // 2.2 그러면, 'window 객체' 는 뭘 의미하지? 
            // BOM 을 의미한다. 
            // Browser Object Model 을 의미. 
            // '브라우저'를 '객체' 모델로 표현한 것. 
            // 지금 이 브라우저와 관련된 모든 것이 담겨져 있다. 


        // 2.3 '일반함수' 에서 'this' 가 가져오는 '객체' 는? 
            // ⭐'실행된 곳'⭐에서 '가까운?' '객체' 를 가져온다. 
                    // 실행된 scope 에서, 객체가 있으면, 그 객체를 가져온다? 
                    // 실행된 scope 에서, 객체가 없으면? 
            // 실행된 곳은 변경될 수 있으니 -> 그래서, '다이나믹 scope' 일까? ❓❓❓ 

        // 2.4 '화살표 함수' 에서 'this' 가 가져오는 '객체' 는? 
            // ⭐'선언된 곳'⭐ 에서 '가까운?' '객체' 를 가져온다. 
            // 화살표 함수 내부의 this 는 화살표 함수를 '선언' 한 위치에서 this 를 가져온다. 
            // 렉시컬 스코드, Lexical Scope
                // lexical = 사전의, 어휘, 의 의미. 
                // 선언된 부분 = 사전과 비슷하지! 
            // 변수를 어디에서 선언했는지에 따라서 변수가 유효한 범위가 결정


        // 2.5 예제 
            
            // 2.5.0 예제 
                // console.log(this)
                    // [해석]
                        // 함수 종류 : ❓ 
                        // 함수 선언 위치 : ❓ 
                        // 함수 실행 위치 : ❓ 
                        // this 가 가리키는 것 : window 
                        // this 와 관련된 함수가 없나❓❓❓❓❓❓ 

            // 2.5.1 예제 1
                
                let d = () => {
                    console.log(this);
                }

                // d()     
                    // [해석] 
                        // 1. this 를 포함하는 건? : 일반함수 
                        // 2. 해당 함수의 선언 위치? : 전역 변수 
                        // 3. 해당 함수의 실행 위치? : 전역 변수 
                        // 4. this 가 가리키는 것은? : window

            // 2.5.2 예제 2 
                
                let obj = {

                    a : function() {
                        b();
                    }
                }

                function b() {
                    console.log(this);
                }

                // obj.a()
                // [해석]
                    // 1. this 는 어디에? : 'b 라는 일반 함수' 안에 있어 
                    // 2. 해당 함수의 선언 위치 : 전역공간
                    // 3. 해당 함수의 실행 위치 : obj.a 함수가 실행되고 -> 중첩된 b 가 나옴. (이 문제가 살짝 애매📛📛📛)
                        // 423line 은 객체 obj가 정의된 곳?   
                        // 431line 이 실행 된 곳? 
                    // 4. this 가 가리키는 것? : window

            
            // 2.5.3 예제 3 

                let obj3 = {

                    a : function() {
                        console.log(this);
                    }
                }
                obj3.a()
                // [해석]
                    // 1. this 는 어디에? : a 라는 일반함수 안에 
                    // 2. a 일반함수의 선언 위치? : 객체 안 
                    // 3. a 일반함수의 실행 위치? : 전역 공간
                    // 4. this 가 가리키는 것? : object 


            // 2.5.4 예제 4

                let person = {
                    name: 'Alice',
                    sayHello: function() {
                        console.log(this);
                    }
                    };
                    
                person.sayHello();
                // [해석]
                    // 1. this 는 어디에? : 일반함수 안에  
                    // 2. 해당 함수의 선언 위치? : 객체 안 
                    // 3. 해당 함수의 실행 위치? : 전역 공간
                    // 3-1 해당 함수의 호출 방법? : '메소드.함수()' 방식 
                    // 4. this 가 가리키는 것? : person 오브젝트                  
            
            // 2.5.5 예제 5 
                let person2 = {
                    name2 : 'Jeong', 
                    hello : function() {
                        console.log(this);
                    }
                };

                let hello = person2.hello;
                hello()
                // [해석]
                    // 1. this 는 어디에? : 일반함수 안에  
                    // 2. 해당 함수의 선언 위치? : 객체 안 
                    // 3. 해당 함수의 실행 위치? : 전역 공간
                    // 3-1 해당 함수의 호출 방법? : '변수 할당 후 함수()' 방식 
                    // 4. this 가 가리키는 것? : window               
            
            console.log("--- 구분선 --- ")

            // 2.5.6 예제 6

                let person3 = {

                    name3 : 'jin',
                    goodEvening : sayName = () => {
                            console.log(this)
                    }
                }
                person3.goodEvening();
                // [해석]
                    // 1. this 는 어디에? : 화살표 함수 안에  
                    // 2. 해당 함수의 선언 위치? : 객체 안 
                    // 3. 해당 함수의 실행 위치? : 전역 공간
                    // 3-1 해당 함수의 호출 방법? : '객체.메소드()' 방식 
                    // 4. this 가 가리키는 것? : window 

            console.log("--- 구분선 --- 👍👍👍  ")

            // 2.5.7 예제 7 
            let person5 = {

                name5 : 'jin',
                saysay : sayName2 = () => {
                        console.log(this)
                }
            }
            let say5 = person5.saysay;
            say5()
                // [해석]
                    // 1. this 는 어디에? : 화살표 함수 안에  
                    // 2. 해당 함수의 선언 위치? : 객체 안 
                    // 3. 해당 함수의 실행 위치? : 전역 공간
                    // 3-1 해당 함수의 호출 방법? : '함수에 변수를 넣고 -> 함수()' 방식 
                    // 4. this 가 가리키는 것? : window 


            console.log("🤟🤟🤟")
            // 2.5.8 : 화살표 함수에서 객체 안에서 실행하게 하는건? 

            let obj6 = {

                a : e = () => {
                    console.log(this)
                }
            }

            obj6.a()    // 호출방식 1 : 객체.메소드() @ 전역 공간
            
            console.log("🔮🔮🔮")
            test = obj6.a
            test()      // 호출방식 2 : 일반함수() @ 전역공간

            console.log("💁‍♀️💁‍♀️💁‍♀️")
            let objtest = {
                name : test()
            }
            objtest.name  // 호출방식 3 : 객체에 넣어서 불리게 해봄. 


            
            let obj7 = {

                a : e = () => {
                    console.log(this)
                    e()
                }
            }
            obj7.a()


        // 🟦 테스트 할 것 
            // 1) this 가 일반함수 안에 있고 2) 정의된 위치는 객체 안 vs 밖 3) 호출 방식은 a) 객체.메소드() @ 전역공간 b) 일반함수()@전역공간 c) 완전히 객체 안에서
            // 1) this 가 화살표 함수 안에 있고 2) 정의된 위치는 객체 안 vs 밖 3) 호출 방식은 a) 객체.메소드() @ 전역공간 b) 일반함수()@전역공간 c) 완전히 객체 안에서



// 🟦 비동기 함수, 동기 함수 

    // 동기 라는 건? 
        // 실행하다가 - 실행 끝나면 실행
        // '순차적' 으로 실행된다. 
        // 작업이 끝나고 -> 다음 작업이 진행 -> 끝나고 다음작업 진행

    // 비동기는? 
        // 다른 작업이 동작되는 와중에도, 자기는 실행된다. 
        // 다른 코드들과 함께 동기적으로 실행되지 않는다. 
        // 전체 코드는 동기적으로 실행되다가, ⭐비동기 함수를 만나면, 비동기 함수를 비동기로 실행하고,⭐ 다시 동기로 실행한다. 
        // 순차적으로 실행되지 않고, 작업을 하는 도중에도 다른 작업이 가능
        // '비동기 함수' 라는 것! 즉 '함수' 라는 것 ⭐⭐⭐ 

        // node.js 에서 잡힐 것 
        // ex) 서버에서 값을 가져오는 동안, 웹 페이지가 뜬다. ⭐⭐⭐⭐⭐ 
            // 데이터 가져오는 걸 = 비동기로 하고, 페이지는 동기적으로 하고 ⭐⭐⭐⭐⭐⭐⭐ 
            // 1) 서버에서 값을 가져오는 동안 = 비동기로 작업 2) 다른 작업들, 페이지가 돌아가는 건, 동기적으로 작업된다. 


    // 비동기 함수의 예시? 
        // settimeout 은 비동기 함수, 
            // 매개변수를 2개 받고, 첫번째가 함수, 두 번째는 시간값을 숫자타입으로 넘겨준다.
            // 1000 = 1초
            setTimeout(function() {
                console.assert("나는 1초 뒤에 실행되고, 나는 비동기 함수에서 실행되었어")
            }, 1000);
    
            setTimeout()
            console.log("나는 동기임");
            console.log("나는 동기임");
    
        // 만약, setTimeout 이 '동기함수' 였다면? 
            // 1000초간 기다렸다가 -> "나는 동기임!" alert 가 떴을 것 ⭐⭐⭐⭐⭐ 
            // 그런데, steTimeout 은 '비동기 함수' 이기 때문에, setTimeout 을 바로 실행하지 않고 -> console.log 로 이동 
    
        // 모르는 부분 📛📛📛 
            // 근데, 시간을 걸었을 뿐, 동기적으로 되는거 아닌가? 
            // 비동기 함수는 일반적으로 이렇게 생긴건가? 
    
        // ⭐⭐⭐ 동기함수, 비동기 함수는 꼭 정해져 있어, 
    
    
    
        // 🟦 let, var, const 는 꼭 써야 함. 
        // window 객체
    
        let a = "";
        
        function temp6() {
            let b = "";
                // 이건 함수 안에서 만 쓸 수 있음. 
                // 함수 밖에서 찍더라도 안 나와
            
            c = "aa"    // 이렇게 하면 '전역 변수' 가 된다 ⭐⭐⭐⭐⭐ 
        }
    
        temp6();
        // 이렇게 되면?    
            // var 아님 
            // 변수로 선언된게 아님 
            // window 객체에 key 값으로 추가된다. ⭐⭐⭐⭐⭐⭐⭐ 
                console.log(window.c)
                console.log(c)
            // 이러면 캊을 수가 없다. 
    
        console.log(c);
        console.log(b);


        
    


                




                

// 궁금한 것 📛📛📛📛📛 
    // 중첩 되어 있으면 바로 위꺼를 실행? 
    // 2.5.2 예제 2 에서, 1) 객체가 정의된 곳이 실행된 곳 인가? 2) 아니면, 객체 함수가 실행된 곳? 
    // 일반함수에서 '실행 위치' 라는게 
        // 1) 2.5.5 예제에서 person.sayHello() 함수는 전역변수에서 호출된건가? 아니면, 객체에서 호출된건가? 



// ✅ 할 것 
    // 1. 구구단 예제를 어디에 넣거나, 올려두기 
    // 2. 스택을 개념적으로는 알겠어. 그러면, 코드로 어떻게 이해하면 좋을까? 
        // `자바스크립트에서 call stack 연습할 수 있는 코드 예제 알려줘` 라고 GPT 한테 물어봐서 예제 풀기 
    // 3. 무명함수 랑 일반함수의 차이 (특히, 무명함수의 선언에 대해서, )

      // 🟦 테스트 할 것 
            // 1) this 가 일반함수 안에 있고 2) 정의된 위치는 객체 안 vs 밖 3) 호출 방식은 a) 객체.메소드() @ 전역공간 b) 일반함수()@전역공간 c) 완전히 객체 안에서
            // 1) this 가 화살표 함수 안에 있고 2) 정의된 위치는 객체 안 vs 밖 3) 호출 방식은 a) 객체.메소드() @ 전역공간 b) 일반함수()@전역공간 c) 완전히 객체 안에서





// 🤟 WIL 
    // 1. 콜백함수는 조건부로 실행하게 하면, 내가 원할 때 실행할 수 있음. 그래서, 여기에 true 를 걸어줌. 

    // 2. , 를 넣어주면, 어떤 값을 받는지 알 수 있음. 
        // ex) console.log(,"나는 콜백함수야!", v + "를 받았어",  b + "도 같이 받았어!", c)

        // 3. 신기한건, ⭐⭐⭐⭐⭐ 
        // '본체함수' 가 매개변수를 수혈받는건, 본체함수를 호출할 때, 
        // '콜백함수' 가 매개변수를 수혈받는 곳은, 본체 함수 안에서, 

    // 4. 함수 부연 설명
        // 4.1 일반함수 : 걍 일반 함수
        // 4.2. 객체 안에 있는 함수 : 메소드  ⭐⭐⭐⭐⭐ 
